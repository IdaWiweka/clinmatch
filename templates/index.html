<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Clinical Entity Matcher</title>
  <style>
    body {
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      margin: 20px;
      padding: 0;
      background-color: #f4f7fa;
      color: #333;
    }
  
    h2 {
      text-align: center;
      color: #2c3e50;
      margin-bottom: 20px; 
    }
  
    label {
      font-weight: bold;
      display: block;
      margin: 15px 0 5px;
    }
  
    select, button {
      padding: 8px 12px;
      font-size: 14px;
      border-radius: 6px;
      border: 1px solid #ccc;
      margin-bottom: 10px;
      width: 100%;
      max-width: 300px;
      box-shadow: 1px 1px 3px rgba(0,0,0,0.05);
    }
  
    button {
      background-color: #3498db;
      color: white;
      border: none;
      cursor: pointer;
      font-weight: 500;
    }
  
    button:hover {
      background-color: #2980b9;
    }

    .main-container {
      display: flex;
      gap: 20px;
   
      margin: 0 auto;
      padding: 20px;
    }

    .text-section {
      flex: 1;
      min-width: 0;
      background: white;
      border-radius: 8px;
      box-shadow: 0 2px 4px rgba(0,0,0,0.05);
      padding: 20px;
    }

    .matching-section {
      flex: 1;
      min-width: 0;
      background: white;
      border-radius: 8px;
      box-shadow: 0 2px 4px rgba(0,0,0,0.05);
      padding: 20px;
    }

    .controls {
      margin-bottom: 20px;
      display: flex;
      flex-wrap: wrap;
      gap: 20px;
    }

    .controls .select-group {
      flex: 1;
      min-width: 200px;
    }

    .controls .matching-methods {
      flex: 1;
      min-width: 200px;
      margin: 0;
      padding: 0;
      background: none;
    }

    .controls label {
      font-weight: 600;
      color: #2c3e50;
      margin: 15px 0 5px;
   
    }

    .controls select {
      width: 100%;
      padding: 10px;
      border: 1px solid #ddd;
      border-radius: 6px;
      font-size: 14px;
      background-color: #f8f9fa;
      transition: all 0.3s ease;
    }

    .controls select:hover {
      border-color: #3498db;
    }

    .controls select:focus {
      outline: none;
      border-color: #3498db;
      box-shadow: 0 0 0 2px rgba(52, 152, 219, 0.2);
    }

    .matching-methods {
      flex: 1;
      min-width: 200px;
      margin: 0;
      padding: 0;
      background: none;
    }

    .method-toggle {
      display: flex;
      align-items: center;
      padding: 12px 15px;
      margin: 8px 0;
      border: 2px solid #e0e0e0;
      border-radius: 8px;
      cursor: pointer;
      transition: all 0.3s ease;
      background: white;
      position: relative;
      overflow: hidden;
    }

    .method-toggle:hover {
      border-color: #3498db;
      background: #f8f9fa;
      transform: translateY(-1px);
      box-shadow: 0 2px 4px rgba(0,0,0,0.05);
    }

    .method-toggle input[type="radio"] {
      margin-right: 10px;
      cursor: pointer;
    }

    .method-toggle input[type="radio"]:checked + span {
      color: #1976d2;
      font-weight: 600;
    }

    .method-toggle span {
      display: flex;
      align-items: center;
      font-size: 14px;
      color: #555;
      transition: all 0.3s ease;
    }

    .method-toggle:hover span {
      color: #1976d2;
    }

    .method-toggle.selected {
      border-color: #1976d2;
      background: #f0f7ff;
    }

    .method-toggle.selected span {
      color: #1976d2;
      font-weight: 600;
    }

    #text-content {
      border: 1px solid #ddd;
      background: white;
      padding: 20px;
      height: calc(100vh - 400px);
      overflow-y: auto;
      border-radius: 6px;
      box-shadow: inset 0 0 5px rgba(0,0,0,0.05);
      margin-top: 20px;
      line-height: 1.6;
      white-space: pre-wrap;
      font-size: 15px;
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    }

    .legend {
      background-color: #f8f9fa;
      border-radius: 6px;
      padding: 15px;
      margin: 20px 0;
      border: 1px solid #ddd;
    }

    .section-header {
      margin: 10px 0 10px;
      font-size: 16px;
      color: #2c3e50;
      border-bottom: 2px solid #3498db;
      padding-bottom: 5px;
      font-weight: 600;
    }

    .entity {
      display: inline-block;
      padding: 8px 12px;
      margin: 5px;
      background-color: #dfefff;
      border: 1px solid #b3d7ff;
      border-radius: 4px;
      cursor: move;
      font-size: 14px;
      transition: all 0.2s ease;
    }

    .entity:hover {
      background-color: #cce5ff;
      transform: translateY(-1px);
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    }

    #entityContainer {
      padding: 20px;
 
      overflow-y: auto;
      background: #f8f9fa;
      border-radius: 6px;
      border: 1px solid #ddd;
      margin: 10px 0;
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
    }

    .drop-zone {
      border: 2px dashed #ddd;
      height: calc(50vh - 400px);
      padding: 15px;
      background: #f8f9fa;
      margin: 10px 0 20px;
      border-radius: 6px;
      transition: all 0.3s ease;
      overflow-y: auto;
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      align-content: flex-start;
    }

    .drop-zone:hover {
      border-color: #3498db;
      background-color: #f0f7ff;
    }

    #undetected_entity {
      width: 100%;
      border-radius: 6px;
      border: 1px solid #ddd;
      margin: 10px 0;
      resize: vertical;
      min-height: 80px;
      font-family: inherit;
      font-size: 14px;
      line-height: 1.5;
    }

    #undetected_entity:focus {
      outline: none;
      border-color: #3498db;
      box-shadow: 0 0 0 2px rgba(52, 152, 219, 0.2);
    }

    #saveButton {
      width: 100%;
      padding: 12px;
      background-color: #2ecc71;
      color: white;
      border: none;
      border-radius: 6px;
      font-size: 16px;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.3s ease;
      margin-top: 20px;
    }

    #saveButton:hover {
      background-color: #27ae60;
      transform: translateY(-1px);
    }

    #status {
      margin-top: 15px;
      font-weight: 600;
      color: #2ecc71;
      text-align: center;
      padding: 10px;
      border-radius: 6px;
      background: #f0fff4;
    }

    .top-bar {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 20px;
      padding: 15px 20px;
      background: white;
      border-radius: 8px;
      box-shadow: 0 2px 4px rgba(0,0,0,0.05);
    }

    .top-bar .left-menu {
      display: flex;
      gap: 10px;
    }

    .top-bar .right-menu {
      display: flex;
      gap: 20px;
      align-items: center;
    }

    .top-bar button {
      background-color: #2ecc71;
      color: white;
      border: none;
      padding: 8px 16px;
      border-radius: 6px;
      cursor: pointer;
      font-weight: 500;
      transition: all 0.3s ease;
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .top-bar button:hover {
      background-color: #27ae60;
      transform: translateY(-1px);
    }

    .top-bar a {
      text-decoration: none;
      color: #666;
      font-weight: 500;
      padding: 8px 12px;
      border-radius: 6px;
      transition: all 0.3s ease;
    }

    .top-bar a:hover {
      background-color: #f8f9fa;
      color: #333;
    }

    .top-bar a.logout {
      color: #e74c3c;
    }

    .top-bar a.logout:hover {
      background-color: #fde8e8;
    }

    .top-bar a.change-password {
      color: #3498db;
    }

    .top-bar a.change-password:hover {
      background-color: #ebf5fb;
    }

    /* Add icons to buttons */
    .top-bar button::before {
      content: "📋";
      font-size: 16px;
    }

    .top-bar a.logout::before {
      content: "🚪";
      margin-right: 5px;
    }

    .top-bar a.change-password::before {
      content: "🔑";
      margin-right: 5px;
    }

    .highlight {
      background-color: yellow;
      font-weight: bold;
    }

    .legend-item {
      display: flex;
      align-items: center;
      margin-bottom: 5px;
    }

    .legend-color {
      display: inline-block;
      width: 20px;
      height: 20px;
      margin-right: 10px;
      border-radius: 4px;
    }
  </style>
</head>
<body>

  <div class="top-bar">
    <div class="left-menu">
      <a href="{{ url_for('review') }}"><button>Saved Data</button></a>
    </div>
    <h2>Clinical Entity Matcher</h2>
    <div class="right-menu">
      <a href="{{ url_for('change_password') }}" class="change-password">Change Password</a>
      <a href="{{ url_for('logout') }}" class="logout">Log Out</a>
    </div>
  </div>

  <div class="main-container">
    <!-- Left side: Text and controls -->
    <div class="text-section">
      <div class="controls">
        <div class="select-group">
          <label>Select Text:</label>
          <select id="text-dropdown">
            <option disabled selected>Select</option>
            {% for text in text_status %}
            {% if not text.is_annotated %}
              <option value="{{ text.text_id }}">
                {{ text.text_id }} — {{ text.text[:10] }}...
              </option>
            {% endif %}
            {% endfor %}
          </select>

          <label for="categorySelect">Category:</label>
          <select id="categorySelect"></select>
        </div>

        <div class="matching-methods">
          <label>Matching Method:</label>
          <label class="method-toggle">
            <input type="radio" name="matchingMethod" value="sentence" checked>
            <span>Sentence Transformer</span>
          </label>
          <label class="method-toggle">
            <input type="radio" name="matchingMethod" value="fuzzy">
            <span>Fuzzy Matching</span>
          </label>
        </div>
      </div>

      <label for="text-content">Text:</label>
      <div id="text-content"></div>
    </div>

    <!-- Right side: Matching interface -->
    <div class="matching-section">
      <div class="legend">
        <div class="section-header">Color Legend:</div>
        <div class="legend-item">
          <span class="legend-color" style="background-color: #ffeb3b;"></span>
          <span>Yellow: Exact match between entity and text</span>
        </div>
        <div class="legend-item">
          <span class="legend-color" style="background-color: #ffa726;"></span>
          <span>Orange: Potential match (high semantic similarity) - Please review carefully as these matches may need verification</span>
        </div>
        <div class="legend-item">
          <span class="legend-color" style="background-color: #dfefff;"></span>
          <span>Blue: No match found</span>
        </div>
      </div>

      <div class="section-header">Entities:</div>
      <div id="entityContainer"></div>

      <div class="section-header">Matched:</div>
      <div class="drop-zone" id="matchedZone"></div>

      <div class="section-header">Unmatched:</div>
      <div class="drop-zone" id="unmatchedZone"></div>

      <div class="section-header">Undetected Entities:</div>
      <textarea id="undetected_entity" rows="4" placeholder="Type undetected entities here"></textarea>

      <button id="saveButton">Save</button>
      <p id="status"></p>
    </div>
  </div>

  <script>
    const textDropdown = document.getElementById("text-dropdown");
    const textContent = document.getElementById("text-content");
    const categorySelect = document.getElementById("categorySelect");
    const entityContainer = document.getElementById("entityContainer");
    const status = document.getElementById("status");
    const matchingMethods = document.getElementsByName("matchingMethod");
    let rawText = "";  // ← store the original unmodified text

    function clearZones() {
      ["entityContainer", "matchedZone", "unmatchedZone"].forEach(id => {
        document.getElementById(id).innerHTML = '';
      });
    }

    function escapeHtml(text) {
    const div = document.createElement("div");
    div.innerText = text;
    return div.innerHTML;
    }

    // Add event listener for matching method changes
    matchingMethods.forEach(method => {
      method.addEventListener('change', function() {
        if (categorySelect.value) {
          categorySelect.onchange();
        }
      });
    });

    textDropdown.onchange = async function () {
      const textId = this.value;

      try {
        const res = await fetch(`/get_text/${textId}`);
        if (!res.ok) throw new Error("Failed to fetch text.");
        const data = await res.json();
        rawText = data.text;  // This is now the formatted text
        
        // Reset everything when new text is selected
        textContent.textContent = rawText;  // Use textContent instead of innerHTML
        clearZones();
        entityContainer.innerHTML = '';
        categorySelect.innerHTML = '';

        const categoryRes = await fetch(`/get_categories/${textId}`);
        if (!categoryRes.ok) throw new Error("Failed to fetch categories.");
        const categoryData = await categoryRes.json();

        for (let catObj of categoryData.categories) {
          let opt = document.createElement("option");
          opt.value = catObj.name;
          opt.textContent = catObj.done ? `${catObj.name} ✅` : catObj.name;
          opt.disabled = catObj.done;
          categorySelect.appendChild(opt);
        }

        if (categorySelect.options.length > 0) {
          categorySelect.selectedIndex = 0;
          categorySelect.onchange();
        } else {
          alert("All categories for this text have been annotated.");
        }
      } catch (err) {
        alert(err.message);
      }
    };

    categorySelect.onchange = async function () {
      const textId = textDropdown.value;
      const category = this.value;
      const matchingMethod = document.querySelector('input[name="matchingMethod"]:checked').value;

      if (!textId || !category) {
        console.log("No text or category selected");
        return;
      }

      try {
        console.log(`Fetching entities for text_id: ${textId}, category: ${category}, method: ${matchingMethod}`);
        const res = await fetch(`/get_entities/${textId}/${category}?method=${matchingMethod}`);
        if (!res.ok) {
          const errorData = await res.json();
          throw new Error(errorData.error || "Failed to fetch entities");
        }
        const { entities, matches } = await res.json();
        console.log("Received entities:", entities);
        console.log("Received matches:", matches);

        // Clear previous content
        clearZones();
        entityContainer.innerHTML = '';
        
        // Reset text content to original formatted text
        textContent.textContent = rawText;
        console.log("Original formatted text:", rawText);

        // Check if there are any entities
        if (!entities || entities.length === 0) {
            const noEntitiesMsg = document.createElement("div");
            noEntitiesMsg.style.cssText = `
                padding: 20px;
                text-align: center;
                color: #666;
                background-color: #f8f9fa;
                border: 1px dashed #ddd;
                border-radius: 6px;
                margin: 10px 0;
                font-style: italic;
            `;
            noEntitiesMsg.textContent = "No entities found for this category.";
            entityContainer.appendChild(noEntitiesMsg);
            return;
        }

        // Apply highlights to the formatted text based on semantic matches
        let highlighted = textContent.textContent;
        let result = '';
        let lastIndex = 0;
        
        // Sort matches by position to avoid overlapping highlights
        matches.sort((a, b) => a.start - b.start);
        
        // Filter out matches that don't have start and end positions
        const textMatches = matches.filter(match => match.start !== undefined && match.end !== undefined);
        
        // Process only matches that have exact text positions
        for (let match of textMatches) {
            console.log(`Processing match: ${JSON.stringify(match)}`);
            // Add text before the match
            result += highlighted.substring(lastIndex, match.start);
            // Add the highlighted match with similarity score
            const similarity = (match.similarity * 100).toFixed(1);
            const highlightedText = match.matched_text || highlighted.substring(match.start, match.end);
            console.log(`Highlighting text: "${highlightedText}" with similarity ${similarity}%`);
            result += `<mark style="background-color: yellow; font-weight: bold;" title="Similarity: ${similarity}%">${escapeHtml(highlightedText)}</mark>`;
            lastIndex = match.end;

            // Add entity to matched zone if it has an exact match
            if (match.start !== undefined && match.end !== undefined) {
                const matchedZone = document.getElementById("matchedZone");
                if (![...matchedZone.children].some(c => c.textContent === match.entity)) {
                    let div = document.createElement("div");
                    div.textContent = match.entity;
                    div.className = "entity";
                    div.style.cursor = "pointer";
                    div.onclick = () => div.remove();
                    matchedZone.appendChild(div);
                }
            }
        }
        // Add remaining text
        result += highlighted.substring(lastIndex);
        
        // Use innerHTML to render the HTML tags
        textContent.innerHTML = result;
        console.log("Final highlighted text:", result);

        // Render entities as draggable items with similarity scores
        for (let e of entities) {
            let span = document.createElement("span");
            span.textContent = e;
            span.className = "entity";
            span.draggable = true;
            span.ondragstart = (ev) => ev.dataTransfer.setData("text/plain", e);
            
            // Find if this entity has a match
            const match = matches.find(m => m.entity === e);
            if (match) {
                const similarity = (match.similarity * 100).toFixed(1);
                span.title = `Similarity: ${similarity}%`;
                
                // If there's an exact match in the text, highlight in yellow
                if (match.start !== undefined && match.end !== undefined) {
                    span.style.backgroundColor = '#ffeb3b';
                    console.log(`Entity "${e}" matched with exact text and similarity ${similarity}%`);
                } else {
                    // If there's only semantic similarity but no exact match, highlight in orange
                    span.style.backgroundColor = '#ffa726';
                    console.log(`Entity "${e}" has high similarity ${similarity}% but no exact match`);
                }
            } else {
                console.log(`Entity "${e}" has no match`);
            }
            
            entityContainer.appendChild(span);
        }
    } catch (err) {
        console.error("Error in categorySelect.onchange:", err);
        alert(err.message);
    }
};

    ["matchedZone", "unmatchedZone"].forEach(id => {
      let zone = document.getElementById(id);
      zone.ondragover = (e) => e.preventDefault();
      zone.ondrop = (e) => {
        e.preventDefault();
        let data = e.dataTransfer.getData("text/plain");
        if ([...zone.children].some(c => c.textContent === data)) return;

        let div = document.createElement("div");
        div.textContent = data;
        div.className = "entity";
        div.style.cursor = "pointer";
        div.onclick = () => div.remove();
        zone.appendChild(div);
      };
    });

    document.getElementById("saveButton").onclick = async function () {
      // Get the original text without HTML tags
      const text = textContent.textContent;
      const category = categorySelect.value;

      const getZoneTexts = (id) =>
        Array.from(document.getElementById(id).children).map(c => c.textContent.trim());

      const entities = Array.from(entityContainer.children).map(c => c.textContent.trim());
      
      const undetected_entity = document.getElementById("undetected_entity").value
        .split("\n")
        .map(e => e.trim())
        .filter(e => e); // remove empty lines

      const payload = {
        text_id: textDropdown.value,
        text: text,
        entities: { [category]: entities },
        matched: { [category]: getZoneTexts("matchedZone") },
        unmatched: { [category]: getZoneTexts("unmatchedZone") },
        undetected_entity: { [category]: undetected_entity }
      };

      console.log("Saving payload:", payload);

      try {
        const res = await fetch("/save", {
          method: "POST",
          headers: { 
            "Content-Type": "application/json"
          },
          body: JSON.stringify(payload)
        });

        if (!res.ok) {
          const errorData = await res.json();
          throw new Error(errorData.message || "Save failed");
        }

        const result = await res.json();
        if (result.status === "success") {
          status.innerText = "Saved successfully!";
          setTimeout(() => status.innerText = "", 3000);

          // Remove saved category from dropdown
          const currentOption = categorySelect.querySelector(`option[value="${category}"]`);
          if (currentOption) categorySelect.removeChild(currentOption);

          if (categorySelect.options.length > 0) {
            categorySelect.selectedIndex = 0;
            categorySelect.onchange();
          } else {
            alert("All categories annotated for this text!");
          }
        } else {
          throw new Error(result.message || "Save failed");
        }
      } catch (err) {
        console.error("Save error:", err);
        alert("Error: " + err.message);
      }
    };

    // Add this to your existing JavaScript
    document.querySelectorAll('.method-toggle').forEach(toggle => {
      toggle.addEventListener('change', function() {
        // Remove selected class from all toggles
        document.querySelectorAll('.method-toggle').forEach(t => {
          t.classList.remove('selected');
        });
        // Add selected class to the checked toggle
        if (this.querySelector('input[type="radio"]').checked) {
          this.classList.add('selected');
        }
      });
    });

    // Initialize selected state
    document.querySelector('.method-toggle input[type="radio"]:checked')
      .closest('.method-toggle')
      .classList.add('selected');
  </script>
</body>
</html>
